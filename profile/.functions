# functions

source .exports

function datedir(){
    echo `date '+%Y-%m-%d'`
    mkdir `date '+%Y-%m-%d'`
}

function git_backup(){
    git clone $1
    cd `basename ${1} .git`
    git_fetch_all_branches
    echo "=========== BRANCHES"
    git branch -a
    echo "===================="
    cd ..
}

function git_fetch_all_branches(){
    git branch -r | grep -v '\->' | while read remote; do git branch --track "${remote#origin/}" "$remote"; done
    git fetch --all
    git pull --all
}

function mkcd () {
    mkdir -p "$@" && cd "$@"
}

# create a new directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$@"
}

# kill process based on a file with its pid.
function kfpid {
    if [ -z "$1" ]; then
        echo "Digite o caminho para o arquivo com o pid."
    else
        kill $(cat $1)
    fi
}

# kill a group of pids based on a query.
function kgpid {
    if [ -z "$1" ]; then
        echo "type the query."
    else
        ps auxww | grep $1 | awk '{print $2}' | xargs kill -9
    fi
}

# create a django project using my project template
make_django_project(){
    django-admin.py startproject --template=https://github.com/arthuralvim/django-boot-template/archive/master.zip --extension=py,env,html,gitignore --name=Procfile,Makefile $1
}

# create a django app using my app template
make_django_app(){
    django-admin.py startapp --template=https://github.com/arthuralvim/django-app-template/archive/master.zip --extension=py,env,html,gitignore --name=Procfile,Makefile $1
}

function gerar_chave_ssh() {
    ssh-keygen -t rsa -b 4096 -C "afmalvim@gmail.com"
}

function install_oh_my_zsh() {

    # check if oh_my_zsh is installed

    # sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"

    if [ $# -eq 0 ]; then
        echo "true"
    else
        echo "false"
    fi

    # check if zsh is default shell

    # chsh -s /bin/zsh

    if [ $# -eq 0 ]; then
        echo "true"
    else
        echo "false"
    fi
}

function install_sublime_settings() {
    rsync -vazh --partial $DOTFILES_DIR/sublime-preferences/ $HOME/Library/Application\ Support/Sublime\ Text\ 3/Packages/User/
}

function install_python_packages() {
    sudo pip install -r PipPackages
    sudo chown $USER $HOME/.pip
}

function remove_dotfiles_settings() {
    for file in {aliases,bash_profile,bashrc,cookiecutterrc,exports,extra,functions,gitconfig,gitignore,global_gitignore,vimrc,zshrc};
    do
        if [ -f $HOME/.$file ]; then
            echo "removing $HOME/.$file"
            rm $HOME/.$file
        fi
    done
    unset file
}

function install_dotfile_settings() {
    for file in {aliases,bash_profile,bashrc,cookiecutterrc,exports,extra,functions,gitconfig,gitignore,global_gitignore,vimrc,zshrc};
    do
        if [ -L $HOME/.$file ]; then
            echo "updating $HOME/.$file"
            rm $HOME/.$file
            ln -s $DOTFILES_DIR/.$file $HOME/.$file
        else
            echo "sending $HOME/.$file"
            ln -s $DOTFILES_DIR/$file $HOME/.$file
        fi
    done
    unset file
}

function install_vim_settings() {
    vim +NeoBundleInstall +qall
}

function set_basic_permissions() {
    sudo chown $USER .pip
}


pipsi-upgrade() {
        for i in $(ls .local/venvs)
        do
                .local/venvs/$i/bin/pip install -U pip wheel
                pipsi upgrade $i
        done
}

#!/bin/bash

# Header logging
e_header() {
    printf "\n$(tput setaf 7)%s$(tput sgr0)\n" "$@"
}

# Success logging
e_success() {
    printf "$(tput setaf 64)âœ“ %s$(tput sgr0)\n" "$@"
}

# Error logging
e_error() {
    printf "$(tput setaf 1)x %s$(tput sgr0)\n" "$@"
}

# Warning logging
e_warning() {
    printf "$(tput setaf 136)! %s$(tput sgr0)\n" "$@"
}

# Ask for confirmation before proceeding
seek_confirmation() {
    printf "\n"
    e_warning "$@"
    read -p "Continue? (y/n) " -n 1
    printf "\n"
}

# Test whether the result of an 'ask' is a confirmation
is_confirmed() {
    if [[ "$REPLY" =~ ^[Yy]$ ]]; then
      return 0
    fi
    return 1
}

# Test whether we're in a git repo
is_git_repo() {
    $(git rev-parse --is-inside-work-tree &> /dev/null)
}

# Test whether a command exists
# $1 - cmd to test
type_exists() {
    if [ $(type -P $1) ]; then
      return 0
    fi
    return 1
}

# Test whether a Homebrew formula is already installed
# $1 - formula name (may include options)
formula_exists() {
    if $(brew list $1 >/dev/null); then
        printf "%s already installed.\n" "$1"
        return 0
    fi

    e_warning "Missing formula: $1"
    return 1
}

function play-ping {
    ansible "$@" -m ping
}

function play-setup {
    ansible "$@" -m setup
}

function play {

    if [ $# -lt 2 ]; then
        echo "Please provide an inventory and play.\nEx: play dev site -l vagrant -t super" >&2
        return 1
    fi

    local check_inventory="$(pwd)/inventories/$1/hosts"
    local check_play="$(pwd)/playbooks/$2.yml"

    echo "inventory: $check_inventory"
    echo "play: $check_play"

    if ! [ -f $check_inventory ]; then
        echo "The inventory file was not found."
        return 1
    fi

    if ! [ -f $check_play ]; then
        echo "The play file was not found."
        return 1
    fi

    local check_extra_vars="$(pwd)/extra-vars.yml"

    if [ -f $check_extra_vars ]; then
        ansible-playbook --inventory-file=$check_inventory $check_play "${@:3}" --extra-vars "@extra-vars.yml"
    else
        ansible-playbook --inventory-file=$check_inventory $check_play "${@:3}"
    fi
}

function git_remote_https_2_ssh {

    if [[ -n "$1" ]]; then
        local repo_full=$(git remote get-url "$1")
    else
        local repo_full="$(git remote get-url origin)"
    fi

    local user="$(echo $repo_full | cut -d "/" -f 4)"
    local repo="$(echo $repo_full | cut -d "/" -f 5)"

    if [[ -z "$user" ]]; then
        echo "The user was not found."
        return 1
    fi

    if [[ -z "$repo" ]]; then
        echo "The repository was not found."
        return 1
    fi

    if [[ -n "$1" ]]; then
        git remote set-url $1 git@github.com:$user/$repo
    else
        git remote set-url origin git@github.com:$user/$repo
    fi
}

function git_remote_ssh_2_https {

    if [[ -n "$1" ]]; then
        local repo_full=$(git remote get-url "$1")
    else
        local repo_full="$(git remote get-url origin)"
    fi

    local repo_full="$(echo $repo_full | cut -d ":" -f 2)"
    local user="$(echo $repo_full | cut -d "/" -f 1)"
    local repo="$(echo $repo_full | cut -d "/" -f 2)"

    if [[ -z "$user" ]]; then
        echo "The user was not found."
        return 1
    fi

    if [[ -z "$repo" ]]; then
        echo "The repository was not found."
        return 1
    fi

    if [[ -n "$1" ]]; then
        git remote set-url $1 https://github.com/$user/$repo
    else
        git remote set-url origin https://github.com/$user/$repo
    fi
}

function nrmod {
    stat -f '%A'
}
